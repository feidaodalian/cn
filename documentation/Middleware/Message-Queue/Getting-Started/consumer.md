# 消费者

消费者Consumer是指具体的客户端消费对象，不等同于消费进程或消费线程。一个应用具体使用多少个消费者与应用场景相关。若消息处理慢，或者耗费大量的CPU，使用少量的消费者是比较合适的。要求并发度高的场景，可以将程序部署在多台物理机上，每个进程使用适量的消费者。

消息队列JCQ消费者分为Pull和Push两种。

## Pull型消费者


**PullConsumer适用于希望由客户端控制拉取频率、消息确认的场景**

PullConsumer实时性不高，实时性取决于客户端的拉取频率。

拉取消息与消息确认（ACK）接口都支持同步和异步两种。

每次Pull请求返回结果包含两部分数据：取到的消息，和这次请求的凭证，凭证用于消息确认。

每次只会轮询选择一个Partition进行拉取，每次默认拉取32条消息。当Topic有多个Partition时，若Partition之间数据不均衡，会存在消息时而能拉到，时而拉不到的情况，这是Pull每次选择一个Partition进行消费导致的。

JCQ 服务端默认开启长轮询，若当前Partition没有消息，Pull请求会被服务端挂起一段时间，当有新消息写入Partition时，立即将挂起的请求唤醒，将消息返回给Consumer，期间，在客户端看来Pull请求是被Block住的。

## Push型消费者

**PushConsumer适用于实时性高的场景**

有新消息写入后，立即将消息推送给客户端。但客户端无法控制推送频率，推送频率由服务端统一管理。Push Consumer的接口相对Pull Consumer比较简单，屏蔽了消息确认的接口，增加了subscribeTopic与unsubscribeTopic。

为了缓解推送消息的速度与业务处理能力的速度不匹配的场景，每个PushConsumer有一个内存队列，消息推来后先进入内存队列。再有一个任务从内存队列中取出消息异步处理。其中队列长度、异步处理任务数都支持配置。
